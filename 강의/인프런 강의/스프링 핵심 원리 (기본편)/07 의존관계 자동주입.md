### 다양한 의존관계 주입 방법
의존관계 주입방법은 4가지가 있다.
생성자 주입, 수정자 주입, 필드 주입, 일반 메서드 주입.

![[Pasted image 20231125160210.png]]
스프링에서 ComponentScan을 하면 OrderServiceImpl을 스프링빈에 등록한다. 
등록할 때 생성자를 호출해야 한다. 
생성자를 호출할 때 @Autowired가 있으면 스프링 컨테이너에서 스프링 빈을 꺼낸다.
memberRepository랑 discountPolicy를 꺼내서 주입을 해준다. 
위처럼 하는 것이 생성자 주입이다. 

```
@Autowired 
 public void setMemberRepository(MemberRepository memberRepository) {
 this.memberRepository = memberRepository;
 }
 
 @Autowired
 public void setDiscountPolicy(DiscountPolicy discountPolicy) {
 this.discountPolicy = discountPolicy;
 }
```
setter에 @Autowired를 붙여주면 수정자 주입이 된다.

스프링 컨테이너는 두 가지 라이프사이클이 있다. 
첫 번째로 스프링 빈을 다 등록하고 두 번째로는 의존관계를 주입한다. 
사실 생성자 주입은 스프링 빈을 등록함과 동시에 의존관계가 주입된다.
나머지는 그렇지 않다.

필드 주입은 이름 그대로 필드에 주입하는 방법이다.
```
 @Autowired
 private MemberRepository memberRepository;
 
 @Autowired
 private DiscountPolicy discountPolicy;
```
코드가 간결하고 좋지만 권장되지는 않는다. 
DI 프레임워크가 없으면 아무것도 할 수 없기 때문.
순수한 Java 코드로 이루어진 테스트 코드를 만들 수 없다.

일반 메서드 주입은 아무 메서드에나 @Autowired를 붙일 수 있다.
```
 @Autowired
 public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
	 this.memberRepository = memberRepository;
	 this.discountPolicy = discountPolicy;
 }
```
하지만 거의 사용하는 일이 없다. 

일반 자바 객체는 @Autowired가 되지 않는다.
스프링 컨테이너에 의해 등록된 스프링 빈만 @Autowired가 된다.

### 옵션 처리




### 생성자 주입을 선택해라!




### 롬복과 최신 트랜드




### 조회 빈이 2개 이상- 문제




### 




### 




### 




