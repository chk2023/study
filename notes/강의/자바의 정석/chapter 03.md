### 연산자와 피연산자
![[Pasted image 20231010093028.png]]
![[Pasted image 20231010093127.png]]
### 연산자의 우선순위와 결합규칙
![[Pasted image 20231010093515.png]]
결합규칙은 연산 순서. 

![[Pasted image 20231010093913.png]]
단항= 피연산자가 1개

### 증감연산자, 부호연산자
![[Pasted image 20231010094421.png]]
독립적으로 사용된 경우?

![[Pasted image 20231010094652.png]]
헷갈리면 이렇게 생각하면 된다. 증가시키고 대입, 대입시키고 증가. 하지만 대입이 없고 독립적으로 사용된다면 전위형 후위형 차이 없음.

### 형변환 연산자, 자동 형변환
![[Pasted image 20231010100424.png]]
변수의 타입을 변환하려면 (타입)피연산자, 이렇게 해주면 된다.
소수를 정수로 변환하면 소숫점은 버려진다. 

자동 형변환은 앞에 (타입)을 붙여주지 않아도 범위가 작은 데이터 값을 범위가 큰 변수에 넣을 수 있다. 컴파일러가 자동으로 형변환을 해준다. 범위는 바이트 기준으로 생각하면 된다. 하지만 강제 형변환을 할 경우 값 손실이 있을 수 있다.

short와 char는 자동 형변환이 안 된다. short는 +/- 3만의 범위, char는 0~6만의 범위.

byte b = 100;
이때는 (타입)을 생략할 수 있다. byte의 범위는 -128~127이다. 따라서 int 타입인 100이 byte에 저장될 수 있기 때문에 컴파일러가 자동 형변환을 해준다. 하지만 100을 i라는 변수에 넣고 i를 byte에 넣어줄 때에는 수동으로 형변환을 해주어야 한다. 컴파일러가 i에 든 값을 확신할 수 없기 때문이다.

### 사칙 연산자, 산술변환
자바에서는 10/4는 2.5가 아닌 2다. int 타입 피연산자끼리의 계산 결과는 int가 되기 때문이다. 
![[Pasted image 20231010102735.png]]
int 피연산자 중 한 쪽을 float로 형변환을 해주면 결과는 float로 나온다.

![[Pasted image 20231010103144.png]]
타입을 변환하면 연산은 큰 범위의 피연산자로 맞춰진다. 

### 반올림 Math.round(), 나머지 연산
Math.round는 실수를 소수점 첫 째자리에서 반올림한 정수를 반환한다.
첫 째자리 말고 원하는 소수점 자리에서 반올림 하려면?
![[Pasted image 20231010103829.png]]
### 비교 연산자, 문자열의 비교
![[Pasted image 20231010104706.png]]

![[Pasted image 20231010104826.png]]
문자열 비교에는 equals()를 사용한다.

### 논리 연산자, 논리 부정 연산자
![[Pasted image 20231010105500.png]]
![[Pasted image 20231010105545.png]]
![[Pasted image 20231010105657.png]]
![[Pasted image 20231010105838.png]]
![[Pasted image 20231010105905.png]]


### 조건 연산자, 대입 연산자
![[Pasted image 20231011163306.png]]
조건식이 참이면 식1을, 거짓이면 식2를 반환한다.

![[Pasted image 20231011163423.png]]

![[Pasted image 20231011163636.png]]
![[Pasted image 20231011163818.png]]



