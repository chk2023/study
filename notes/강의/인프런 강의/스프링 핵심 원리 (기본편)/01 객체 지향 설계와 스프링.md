### 자바 진영의 추운 겨울과 스프링의 탄생
2000년대 초반
EJB(Enterprise Java Beans; J2EE) - 자바 진영의 표준 기술
분산기술 , 트랜잭션 선언, Entity Bean(ORM) 등등의 장점이 있었다. 
단점은 가격이 비쌌다는 것.
EJB는 비싸기도 했지만 너무 복잡했다.
따라서 POJO라는 단어가 나왔다. 예전으로 돌아가자!

EJB 지옥 때문에 도저히 안되겠다 싶은 개발자 두명.
개빈킹 - EJB Entity Bean이 너무 불편해서 하이버네이트 만듦
로드존슨 - 스프링 만듦

결국 현재는 ORM으로 JPA 인터페이스 사용, 구현체는 Hibernate. 

로드존슨이 EJB를 극복할 수 있는 방안에 관한 책을 내자 유겐 휠러와 얀 카로프가 오픈소스 프로젝트 제안. 
스프링 핵심 코드 상당수는 유겐 휠러가 개발. 
얀 카로프가 Spring이라는 이름을 지었다. 겨울을 지나 Spring, 봄을 가져다 오길 희망하며.

![[Pasted image 20231013200733.png]]


### 스프링이란?
필수: 스프링 프레임워크, 스프링 부트
선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드

![[Pasted image 20231014101621.png]]
![[Pasted image 20231014101833.png]]


### 좋은 객체 지향 프로그래밍이란?

객체지향 프로그래밍의 좋은 점은 코드가 유연하고 변경이 용이하다는 것이다.
그것이 바로 다형성이다.

다형성
다형성을 실세계에 비유해서 설명한다. 역할과 그 역할을 수행하는 구현으로 세상을 구분한다.
![[Pasted image 20231014103308.png]]
운전자는 K3에서 테슬라로 차를 바꿔도 운전을 그대로할 수 있다. 
어떤 자동차든 자동차의 역할만 수행한다면 운전자는 그 자동차들의 조종법을 알 것이다.
운전자는 자동차의 역할에 대해서만 의존하고 있다. 
자동차 내부가 변경되어도 역할에만 충실하면 클라이언트(운전자)에게 영향을 미치지 않는다.
자동차 세상을 무한히 확장 가능한 것이다. 이것이 다형성이다.
즉, 클라이언트에게 영향을 주지 않고 새로운 기능을 제공할 수 있다. 

![[Pasted image 20231014103823.png]]
![[Pasted image 20231014103927.png]]
인터페이스 말고도 일반적인 상속관계도 다형성이 가능하긴 하지만 인터페이스를 사용하는 것이 좋다. 

![[Pasted image 20231017172324.png]]
클라이언트가 동시에 서버가 되어 요청에 응답할 수가 있다. 

![[Pasted image 20231017172448.png]]
멤버 서비스가 save() 메서드를 호출한다. 객체가 메모리 멤버 레파지토리에 있으면 거기서 호출하고, Jdbc 멤버 레파지토리에 있으면 거기서 호출.

![[Pasted image 20231017172800.png]]
![[Pasted image 20231017172835.png]]
멤버 서비스가 바라보는 것을 메모리 멤버 레파지토리로 바꿀 수 있고 Jdbc 멤버 레파지토리로 바꿀 수 있다. 이것이 바로 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다는 예시

![[Pasted image 20231017172957.png]]
![[Pasted image 20231017173040.png]]
인터페이스를 안정적으로 잘 설계하는 것이 중요하다. 인터페이스가 변하면 클라이언트, 서버 모두에 큰 변경 발생. 

![[Pasted image 20231017173137.png]]
스프링의 가장 핵심은 다형성이다.
스프링은 다형성을 극대화한다. 
IoC, DI는 모두 다형성을 활용하는 것이다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

![[Pasted image 20231017190209.png]]
변경이 있을 때 파급이 적으면 책임이 적은 것이다.

![[Pasted image 20231017190405.png]]
OCP에도 문제가 있다.
멤버 서비스는 직접 구현 클래스를 선택한다.
처음에는 메모리 멤버 레파지토리였지만 Jdbc 멤버 레파지토리로 변경했다.
변경에는 닫혀 있어야 한다 했는데 어쩔 수 없이 변경하게 된 것. 
그렇다면 어떻게 해결해야 하는가? 
객체를 생성하고 관계를 맺게 해주는 별도의 설정자가 있어야 한다.
이 별도의 행위는 스프링이 해준다. 
OCP 원칙을 지키려면 DI도 필요하고 IOC 컨테이너도 필요하다. 

![[Pasted image 20231017191605.png]]
![[Pasted image 20231017191617.png]]
![[Pasted image 20231017191732.png]]
제일 중요한 원칙은 OCP, DIP.
DIP는 쉽게 말해 클라이언트 코드가 구현 코드를 바라보지 말고 인터페이스를 바라보라는 것이다. 위의 예로 말하면 멤버 서비스가 메모리 멤버 레파지토리나, Jdbc 멤버 레파지토리의 내용에 대해 몰라야 된다는 것이다. 
운전자는 자동차의 역할에 대해 알아야 하는 거지 K3의 세세한 기능에 대해 알면 안 된다. 
클라이언트 코드는 구현체가 아닌 인터페이에 의존하도록 설계해야 한다. 

![[Pasted image 20231017192411.png]]

### 객체 지향 설계와 스프링
![[Pasted image 20231017193944.png]]
![[Pasted image 20231017194018.png]]
![[Pasted image 20231017194055.png]]
![[Pasted image 20231017194435.png]]
추상화가 되면 개발자가 코드를 한 번 더 열어봐야 한다.
런타임에 메모리 멤버 레파지토리를 쓸지 JDBC 멤버 레파지토리를 쓸지 여러 개 중 선택을 해야 한다. 하지만 코드만 보면 바로 인터페이스가 보이기 때문에 구현 클래스가 뭔지 잘 보이지 않는다. 