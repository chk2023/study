### 객체지향 언어

![[Pasted image 20231014105430.png]]
객체지향 언어는 기존 프로그래밍 언어에 객체지향 개념/규칙을 추가한 것이다.
OOP에는 4가지 핵심 개념이 있다. 캡상추다.

공부순서
6장, 7장 객체지향 공부 -> 스프링 실습 -> 디자인 패턴
실습하면서 하나하나 이해하지말고 따라해보기. 이론서로 빠지지 않고 만들어보기.

### 클래스와 객체
![[Pasted image 20231016112236.png]]

![[Pasted image 20231016113859.png]]
실제세계를 어떻게 컴퓨터 안에 반영할 수 있을까? 객체를 만든다.
예를 들면 스피커(hw)를 컴퓨터 오디오 player(sw)로 만드는 것.
하드웨어를 분석하고 관찰하니까 객체는 속성과 기능으로 이루어져있다는 것을 알아냈다.
속성과 기능 = 변수와 메서드.

객체는 모든 인스턴스를 대표하는 일반적 용어. 인스턴스는 특정 클래스로부터 생성된 객체.
클래스를 만들고 난 후에는 인스턴스를 따로 만들어야 사용할 수 있다. 
인스턴스를 사용한다는 것은 클래스에서 정의한 속성과 기능을 사용한다는 의미.

### 한 파일 여러 클래스 작성하기
![[Pasted image 20231016115548.png]]
하나의 소스파일에 여러 클래스가 있는 경우, public class가 붙은 클래스의 이름을 소스파일과 일치시켜야 한다. 하지만 public class가 없는 클래스뿐이라면 이들 클래스 중 아무 클래의 이름과 소스파일에 이름을 일치시켜도 된다. 
하나의 소스파일에는 반드시 하나의 public class만 있어야 한다. 
하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직하다.
소스파일과 메인 메서드가 있는 클래스 이름은 꼭 일치해야 한다.

### 객체의 생성과 사용
![[Pasted image 20231016144431.png]] 
객체를 생성하고 참조변수에 대입한다.
객체를 사용하려면 변수와 메서드를 사용해야 한다. 
t.channel은 Tv 인스턴스의 멤버변수 channel의 값을 7로 한다는 것. 
클래스 작성(설계도) >> 객체생성(제품) >> 객체사용(제품사용) 

![[Pasted image 20231016145445.png]]
그림에서 말하는 Tv 리모콘은 Tv 타입의 t 참조변수.
참조변수의 타입과 생성하려는 객체의 타입은 일치해야 한다.
new Tv(); 에서 new 연산자가 객체를 만들고 객체의 주소를 알려준다. 
그 후 객체의 주소가 참조변수에 저장된다. 
메모리에 객체는 어떻게 생성되는가? 클래스에 설계대로 생성된다. 
그렇다면 객체의 값은? 처음 초기화된 값으로 설정된다.

![[Pasted image 20231016145839.png]]
TV 타입의 새로운 참조변수를 만들 때마다 새로운 객체가 생성된다. 이렇게 새롭게 생성된 객체는 다양하게 사용될 수 있다. 

여러 개의 참조변수가 하나의 인스턴스를 가리키는 것은 가능.
하나의 참조변수가 여러 인스턴스를 가리키는 것은 불가능. 
변수는 하나의 값만 저장할 수 있으므로 참조변수는 두 개 이상의 주소를 가질 수 없다.
참조변수가 없는 객체는 GC가 자동으로 제거. 

객체 설계는 다른 자바 소스파일 Class로 정의. 객체 생성과 사용은 메인 메서드에서 실행.

### 객체배열
![[Pasted image 20231016151742.png]]
객체배열은 참조변수 배열이다. 이 배열의 값은 주소가 저장된다. 

![[Pasted image 20231016152036.png]]
tvArr이라는 참조변수가 만들어지고 Tv타입 참조변수 3개가 tvArr에 대입.

### 클래스의 정의
![[Pasted image 20231016152553.png]]

![[Pasted image 20231016153059.png]]
시간의 시, 분, 초를 나타내는 변수를 만들었다고 가정하자. 시는 시끼리, 분은 분끼리, 초는 초끼리 배열로 묶으면 시, 분, 초를 함께 사용할 수가 없게 된다. 따라서 Time이라는 타입의 클래스를 만들어 변수들을 관리하고 이를 객체를 통해 접근할 수 있다. 

![[Pasted image 20231016153308.png]]

### 선언위치 변수종류

![[Pasted image 20231016154052.png]]
변수의 종류는 선언위치에 따라 세 가지 종류를 가진다. iv, cv, lv.
클래스 영역 = iv, cv
메서드 영역 = lv
lv는 메서드가 종료되면 지역변수가 사라진다. 

iv는 인스턴스가 생성되면 생성된다. 
객체를 생성해야 iv를 저장하는 메모리 공간이 할당된다.
cv는 클래스가 메모리에 올라갈 때 생성된다. 
객체가 생성되기 이전에 설계도인 클래가 먼저 생성된다.

CPU는 저장장치(SSD, HDD)에서 자바 소스파일을 가져올 수 없다.
아무리 저장장치가 빨라졌다 해도 CPU가 압도적으로 빠르며 이 속도차이 때문에 가져올 수 없는 것. 그래서 RAM에 파일을 먼저 로딩해야 한다. 
메모리에서 사용한 이후 저장장치에 세이브한다. 
cv는 객체생성이 필요 없다. cv는 아무때나 사용 가능. 하지만 불필요하게 메모리에 올리면 메모리 낭비가 된다.

클래스 영역에는 선언문만 가능하다. 변수 선언, 메서드 선언(메서드 정의).
y=x+3, System.out.prin(); 이러한 명령어는 불가능하다.

### 클래스 변수, 인스턴스 변수
![[Pasted image 20231016160117.png]]
개별적은 속성은 iv로, 공통적인 속성은 cv로 선언.
공통되는 값을 매번 새롭게 메모리 공간에 할당한다면 그것은 낭비.

![[Pasted image 20231016160225.png]]
cv는 앞에 클래스 이름을 붙이는 것이 권장된다. iv랑 구분하기 위함.

### 메서드란? 메서드의 선언부와 구현부

![[Pasted image 20231016163253.png]]
![[Pasted image 20231016163729.png]]
메스드는 0~1개의 값을 출력한다. 여러 개의 값을 출력하려면 객체에 담아서 출력한다.

### 메서드 호출
클래스에서 메서드 작성 >> 객체생성 >> 객체사용(메서드 호출) >> 예) mm.add();

![[Pasted image 20231016165900.png]]
### return문, 반환값

return문은 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아감.
반환 타입이 void면 return 생략 가능. 

![[Pasted image 20231016171433.png]]
두 번째 예시는 거짓일 때 return문이 없는 경우이므로 에러 발생. 
return에 대상이 되는 값의 타입은 메소드의 타입과, 결과가 대입될 변수의 타입과 같아야 함.

### 호출스택(call stack)
![[Pasted image 20231017103419.png]]
스택은 넣을 때 1번과 2번 사이에 넣을 수 없고, 꺼널 때 중간에 있는 것을 뺄 수 없다. 스택은넣을 때와 꺼낼 때 순서가 있다.

![[Pasted image 20231017103717.png]]
main 메서드가 실행되면 호출스택에 메모리가 할당된다. 그 후 main 메서드가 println 메서드를 호출하면 main 메서드 위에 println 메서드가 올라가고 main 메서드는 대기 상태, println은 실행 상태가 된다. println 메서드가 종료되면 메모리에서 해제되고 main 메서드만 남게된다. 그후 메인 메스드가 실행상태. 

호출스택에서는 아래의 메소드가 위의 메소드를 호출한다. 스택을 보면 누가 누구를 호출했는지 알 수 있다. 맨 위의 메서드 하나만 실행 중이고 나머지는 대기한다. 

### 기본형 매개변수

![[Pasted image 20231017104642.png]]
기본형 매개변수는 읽기만 가능하다.
참조형 매개변수는 읽기, 변경 다 가능.
위는 기본형 매개변수의 값을 10에서 1000으로 변경해준 것이 아니다.
change 메서드에 올라온 x를 1000으로 대입한 것.
객체의 x 값을 변경하고 싶으면 매개변수를 참조형을 사용해야 한다.

### 참조형 매개변수, 참조형 반환 타입
![[Pasted image 20231017105411.png]]
매개변수가 참주형이면 객체의 주소를 복사해준다.
이 객체의 주소를 갖게된 change 메서드는 쉽게 객체의 멤버변수의 값을 가져온다.

![[Pasted image 20231017110137.png]]
반환타입이 참조형이면(여기서는 Data3가 참조형 반환타입) 객체의 주소를 반환한다. 

### static 메서드와 인스턴스 메서드
![[Pasted image 20231017112856.png]]
Math.random()은 static 메서드. Math가 클래스 이름이다. 객체를 따로 생성하지 않아도 사용할 수 있다.

![[Pasted image 20231017113610.png]]
위 static 메서드의 long a, long b는 지역 변수다. 따라서 iv가 아니기 때문에 static 메서드로써 사용됨. return문 뒤 a, b 역시 lv다. iv랑 lv 중 가까운 쪽으로 형태를 갖는다. iv보다는 lv에 가깝기 때문에 lv인 것.

즉, static 메서드는 객체 생성 없이 호출이 가능하며 iv를 사용하지 않을 때 사용하는 메서드라고 할 수 있다. 

멤버변수 중 공통 속성을 가지면 static을 붙인다. 
iv, im을 사용하지 않는 메서드에 static을 붙인다. 

![[Pasted image 20231017115056.png]]
인스턴스 메서드 역시 객체 생성 후 호출 가능. 인스턴스 메서드를 호출하려 객체가 생성 되었다는 뜻은 iv 역시 사용 가능하다는 것. iv 역시 객체 생성 후 사용할 수 있기에.
하지만 static 메서드는 iv 사용불가. 
static 메서드가 호출되었을 때 객체가 생성 되었는지 안 되었는지 모르기 때문에 iv를 사용할 수 없는 것이다. 


### 오버로딩

![[Pasted image 20231017115918.png]]
오버로딩은 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것. 
오버로딩은 과적. 하나의 메서드 이름은 하나의 메서드와 매핑되어야 하지만 하나의 메서드 이름으로 여러 메서드가 매핑된 경우 과적이라고 할 수 있다.
오버로딩의 예는 println() 메서드. 

![[Pasted image 20231017120243.png]]
보기1은 메서드 이름은 같지만 매개변수의 개수와 타입이 같다. 이런 경우에는 오버로딩이 아니라 메서드 중복 정의이며 에러가 난다. 에러는 add(int, int) is already defined. 
보기3은 오버로딩. 하지만 add(3,3)을 호출하면 컴퓨터가 둘 중 어느 메서드를 호출할지 판단할 수 없다. add(3, 3L)은 첫 번째 메서드 호출. 

### 생성자, 기본 생성자

생성자는 인스턴스가 생성될 때마다 호출되는 인스턴스 초기화 메서드다. 
인스턴스 초기화는 인스턴스의 변수와 메서드에 값을 대입해주는 것.
인스턴스는 처음에 모두 자동으로 0, null이 추가된다. 이를 초기화해주어야 함.

![[Pasted image 20231017124224.png]]
위 보다는 아래 처럼 Time t= new Time(12, 34, 56);으로 적어주는 것이 더 깔끔하다. 
이것이 생성자 호출이다. iv초기화를 편리하게 하기 위해 사용하는 것.

![[Pasted image 20231017124654.png]]

![[Pasted image 20231017124956.png]]
"생성자가 하나도 없을 때"만 컴파일러가 기본 생성자를 자동으로 추가한다.

![[Pasted image 20231017125418.png]]
Data_2 클래스에 이미 생성자가 있다. 
따라서 컴파일러가 기본 생성자를 자동으로 추가하지 않았다.
메인 메서드에서 Data_2 객체는 기본 생성자 호출을 했기 때문에 에러가 났다.
기본 생성자 호출을 하려면 기본 생성자를 사전에 만들어야 하며 이 때 생성자가 하나도 없을 때만 컴파일러가 기본 생성자 추가. 
에러가 나지 않게 하려면 Data_2(){}; >> 기본 생성자를 추가해야 한다.

![[Pasted image 20231017125919.png]]
생성자를 만들어준 뒤, 우측과 같이 간단하게 호출하면 된다. 좌측은 너무 번거롭다. 
하지만 생성자가 객체를 만드는 것은 아니다. 생성자 호출 과정에서 new 연산자가 객체를 메모리에 생성.  

### 생성자 this(), 참조변수 this

![[Pasted image 20231017150709.png]]
같은 클래스 안의 생성자끼리 호출할 때는 this()를 사용한다.
우측 보기는 두 가지 에러가 난다. 같은 클래스 안의 생성자를 호출할 때 this()를 사용하지 않았다. 생성자 호출을 첫 줄에서 하지 않고 두 번째 줄에서 했다.

![[Pasted image 20231017152439.png]]
this()는 생성자고 this는 참조변수다. 
this는 인스턴스 자신을 가리키는 참조변수다. 
생성자를 포함한 인스턴스 메서드에서 사용가능하다.
lv와 iv를 구별할 때 사용. 

![[Pasted image 20231017152810.png]]
static 메소드에서는 this 사용불가. this는 인스턴스 메서드와 생성자에 사용 가능하다. 

### 변수의 초기화, 멤버변수의 초기화

![[Pasted image 20231017153440.png]]
지역변수는 반드시 수동 초기화 해야 한다. 
멤버 변수(iv, cv)는 자동 초기화된다. 














