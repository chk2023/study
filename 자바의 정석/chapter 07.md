### 상속
![[Pasted image 20231018101054.png]]

![[Pasted image 20231018101329.png]]
아래 자식 클래스는 멤버가 없는 게 아니다. 자신의 멤버는 0개지만 상속받은 멤버는 1개다.
자손의 변경은 조상에 영향을 미치지 않는다. 

![[Pasted image 20231018101605.png]]

### 클래스 간의 관계, 상속과 포함

![[Pasted image 20231018102949.png]]
클래스의 관계는 상속과 포함으로 나뉜다. 
우측 예시를 보면 circle은 point를 포함하고 있는 관계다.
point 클래스에 x, y 멤버변수를 선언하고, circle 클래스에 포함시켜 주었다.
포함 방법은 참조변수를 선언해주는 것.
포함할 클래스의 타입으로 참조변수를 선언하고 new 연산자로 생성자를 호출한다.

Cirlce c = new Circle(); 객체를 만들었다고 가정.
좌측 예시에서는 참조변수 c에 x, y, r 변수의 값이 담긴 객체의 주소가 대입된다.
우측 예시에서는 참조변수 c에 c(Point 타입)와 r 변수의 값이 담긴 객체의 주소가 대입되며,
c(Point 타입)는 자신이 참조하는 x, y의 값이 담긴 객체의 주소를 가진다. 
보통은 c.x, c.y, c.r 이렇게 멤버변수를 사용하지만,
Point 클래스의 멤버변수를 사용하려면 c.c.x, c.c.y 이런식으로.

스프링에서 서비스 또는 컨트롤러에 뜬금 없이 레파지토리나 도메인 클래스 타입을 가진 객체를 멤버 변수로 사용하는 것이 위와 같은 포함관계를 갖게 해준 것?

![[Pasted image 20231018103834.png]]
상속 관계를 갖게 해줘야 할 지 포함 관계를 갖게 해줘야 할 지 고민이라면 문장을 만들어 보면 된다. 
상속관계: ~은 ~이다.(is-a) / 포함관계: ~은 ~을 가지고 있다.(has-a)
예시는 두 번째가 "원은 점을 가지고 있다"라는 문장이 더 자연스럽기 때문에 포함관계로 설정해주면 된다. 
상속은 제한이 있기 때문에 꼭 필요할 때만 사용한다. 대부분 포함관계를 사용한다.

### 단일 상속, Object 클래스

![[Pasted image 20231018105635.png]]
자바는 단일상속만 허용한다. 하나의 부모로부터만 상속받음. 
class TvDVD extends Tv, DVD (x)
다중상속은 문제가 있다. 부모 클래스 모두 voidpower()라는 메서드가 있으면,
자식 클래스에서 voidpower() 메서드를 호출할 때 둘 중 어느 메서드를 호출해야 할 지 애매하다.

보통 비중이 높은 클래스 하나만 상속관계로 설정하고, 나머지는 포함관계로 설정한다.
인터페이스를 이용하면 위 같은 충돌문제를 해결하면서 다중상속을 할 수 있다.

![[Pasted image 20231018110337.png]]
Object 클래스는 모든 클래스의 조상이다. 
부모가 없는 클래스는 자동적으로 Object 클래스를 상속받는다. 
상속받는 클래스가 없는 클래스는 컴파일러가 자동으로 Object 클래스를 상속 받는다.
모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다.
toString(), equals(Object obj), hashCode()...
toString() 메서드는 클래스의 이름+@+주소값을 출력한다.

### 오버라이딩

![[Pasted image 20231018152025.png]]
오버라이딩은 상속받은 조상의 메서드를 자신에 맞게 변경하는 것이다. 
단 구현부만 변경할 수 있다.

![[Pasted image 20231018153254.png]]
![[Pasted image 20231018153237.png]]

![[Pasted image 20231018153706.png]]
오버로딩은 이름이 같을뿐 새로운 메서드를 정의하는 것이다.
오버라이딩도 새로운 메서드를 만드는 것은 맞다.
단 오버라이딩은 상속과 관계있고 오버로딩은 상속과 관계가 없다.
5번은 중복정의 = 에러.

### 참조변수 super, 생성자 super()

참조변수 super는 this와 비슷하다. 인스턴스 메서드(생성자)내에서만 사용 가능하다. 
static 메서드에서 사용 불가하다.
조상의 멤버를 자신의 멤버와 구별할 때 사용한다. 
this는 lv와 iv 구분할 때.

![[Pasted image 20231018164648.png]]
부모 클래스의 멤버 변수 x, 자식 클래스의 멤버 변수도 x다. 값이 다르긴 하지만.
여기서 this는 인스턴스 자신을 가리키고 super는 부모 클래스를 가리킨다. 
첫 번째 x는 값이 20. 가장 가까운 값이 20이기 때문.
this.x는 값이 20. 인스턴스 자신을 가리키기 때문에 Child 클래스의 멤버변수. super.x는 값이 10. 부모 클래스의 값.

생성자와 초기화 블럭은 상속이 안 된다. 따라서 super()를 이용해 조상의 생성자를 호출해서 초기화한다. 

```
생성자란?
생성자는 멤버를 초기화 하는 메서드다.

생성자는 어떻게 초기화를 하는가?
new 연산자를 통해 생성자를 호출하면 객체(멤버)가 메모리에 올라가고,
기본 생성자일 경우 자동으로 초기화하여 0, null, boolean 등의 값으로 초기화,
생성자의 파라미터가 있는 경우 파라미터 값으로 초기화를 한다.

조상의 생성자를 호출한다는 것은?
조상의 객체(멤버)를 사용하기 위해 메모리에 올리고 멤버의 값을 초기화한다는 것.
```

![[Pasted image 20231018170852.png]]
super(x, y)는 Point(int x, int y)

![[Pasted image 20231018172354.png]]
(중요)생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
첫 줄에 생성자를 호출하지 않는 경우 컴파일러가 super();를 삽입한다.
우측의 super();는 Point 클래스의 조상인 Object의 기본 생성자를 호출하는 코드.

기본 생성자를 컴파일러가 자동으로 추가해준다 해도 생성자가 하나도 없는 경우에 만들어준다는 제한사항이 있기 때문에 실수를 하지 않기 위해서라도 기본 생성자는 항상 만들어야 한다.

### 패키지, 클래스 패스
![[Pasted image 20231018173900.png]]

![[Pasted image 20231018174039.png]]

bin 폴더에는 컴파일된 클래스 파일(.class)이 있고 src 폴더에는 소스파일(.java)이 있다.
bin은 패키지 루트이며 터미널로 클래스 파일을 실행하고 싶으면 해당 클래스 파일이 있는 디렉토리로 이동해야 한다.
실행은 java + 패키지명.

![[Pasted image 20231018175439.png]]
시스템 환경 변수를 설정해주어야 컴파일러가 클래스 파일의 위치를 찾을 수 있다.
환경 변수를 설정해주면 클래스 파일이 있는 디렉토리에 가지 않아도 터미널에서 클래스 파일을 실행할 수 있다. 


### import문, static import문

![[Pasted image 20231018185506.png]]
원래는 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
java.lang 패키지는 import 해주지 않아도 된다. String, Object, System, Thread...

![[Pasted image 20231018185612.png]]

![[Pasted image 20231018185801.png]]
import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없다. 물론 컴파일할 때 조금 더 걸릴 수는 있다. 만약 실행 시에 처리되면 성능에 영향을 준다.

![[Pasted image 20231018190143.png]]
static import문은 static 멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.

### 제어자, static, final, abstract

![[Pasted image 20231018191353.png]]

![[Pasted image 20231018191457.png]]
static은 객체 생성 없이 사용 가능하다. 하지만 객체를 필요로 하는 인스턴스 멤버들을 사용할 수 없다. 

![[Pasted image 20231018191955.png]]
final 클래스는 조상이 될 수 없는 마지막 클래스. String과 Math가 final class다. String은 보안 때문에. 비밀번호를 상속받아서 변경하면 곤란하다. 

![[Pasted image 20231018192623.png]]
구현부가 없는 메서드를 추상 메서드라고 하며 추상 메서드를 포함하는 클래스를 추상 클래스라고 한다.
추상 메서드는 구현부는 없고 선언부만 있는 미완성 메서드이다. 
추상 클래스는 미완성의 설계도이므로 제품 생성이 불가하다. 즉, 추상 클래스의 인스턴스를 생성하지 못한다는 의미다. 
그렇다면? 추상클래스를 상속받아서 완전한 클래스를 만들어야 한다. 그 후 객체 생성.


### 접근제어자

![[Pasted image 20231018194613.png]]
class에는 public과 default, 멤버에는 4가지 다 붙을 수 있다.

### 캡슐화

![[Pasted image 20231018202421.png]]
접근 제어자는 외부로부터 데이터를 보호해준다.
iv는 외부에서 접근을 막고 메소드를 통해 iv에 접근할 수 있게 한다. getHour, setHour.
또한 접근 제어자는 외부에는 불필요한, 내부적으로만 사용되는 내용을 감춘다.

```
class Time {  
    private int hour;  
    private int minute;  
    private int second;  
  
    // 멤버 변수가 private이기 때문에 객체를 만들어서 접근 할 수 없다.  
    // 따라서 getter, setter 메서드를 생성해서 간접적으로 접근한다.  
    public void setHour(int hour){  
        if(hour < 0 || hour > 23) return; 
        //false면 return문에 의해 제어문을 빠져나간다.
        this.hour = hour;  
    }  
  
    public int getHour() {return hour;}  
}  
  
public class TimeTest {  
    public static void main(String[] args) {  
        Time t = new Time();  
        // t.hour = -100; 멤버 변수가 private이기 때문에 에러.  
        t.setHour(21);  
        System.out.println(t.getHour());  
    }  
}
```

### 다형성

다형성이란 자손 타입 객체를 조상 타입 참조변수에 대입가능한 것.
즉, 조상 타입 참조 변수로 자손 타입 객체를 다루는 것.
하지만 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.

![[Pasted image 20231018210043.png]]
첫 번째 방식과 다르게 두 번째 다형성을 적용한 방식은 객체는 7개를 가지지만, 7개의 멤버 중 5개만 사용할 수 있다. 이것이 장점이 된다?

### 참조변수의 형변환

기본형의 형변환은 값이 바뀐다. 3.6을 int로 바꾸면 3이 되는 것처럼.
참조변수의 형변환은 사용할 수 있는 멤버의 갯수를 조절한다.

![[Pasted image 20231018220102.png]]
조상-자손 관계만 서로 형변환이 가능하다.
예) 자손 객체가 대입된 참조변수 f를 부모 클래스 참조변수 c에 대입하려 하면 타입이 맞지 않기 때문에 (자손은 FireEngine타입) Car 타입으로 형변환을 해준다.
형변환을 해주었더라도 c 참조변수가 f 참조변수처럼 객체를 5개 다 쓸 수 있는 건 아니다. 
참조 변수 f의 주소를 c에 넣어주었다. c는 f 참조변수가 참조하는 주소를 갖게 된 것이다. 
그러나 c 참조변수가 가지는 멤버변수는 4개의 불과하기 때문에 f 참조변수가 참조하는 water() 메소드는 사용할 수 없는 것이다. 
하지만 역으로 c 참조변수가 참조하는 주소를 f2에 대입하면 다시 5개를 사용하는 것이다.

### 참조변수의 형변환 2

![[Pasted image 20231018221407.png]]
경우에 따라서 부모 참조변수가 자식 참조변수에 대입될 때 실행 에러가 난다.
c참조변수는 참조하는 객체가 4개다. fe 참조변수는 water() 메서드를 사용할 수 없다.
이유는 Car 인스턴스에 water() 메서드가 없기 때문이다.

### instanceof 연산자

![[Pasted image 20231018222224.png]]
여기서 instanceof는 c 참조변수가 FireEngine의 자손인지 물어본다. 
true가 나오면 그 후 형변환.

### 매개변수의 다형성

![[Pasted image 20231018223620.png]]
다형성의 두 가지 장점.
첫 번째가 다형적 매개변수, 두 번째가 하나의 배열로 여러 종류의 객체를 다룰 수 있다는 점.

![[Pasted image 20231018224226.png]]
buy() 메소드의 파라미터로 참조변수를 넣어주려 한다. Tv, Computer, Audio.
따라서 같은 이름의 메소드를 오버라이딩 해주었다. 하지만 제품은 수도 없이 많다.
이 모든 제품을 오버로딩 할 수는 없다.
따라서 Product 타입의 p 참조변수를 매개변수로 해주고 다음과 같이 다형성을 적용하여
```
Product p1 = new Tv();
Product p2 = new Computer();
Product p3 = new Audio();
```
tv와 com 참조변수를 사용할 수 있다.

참조변수와 문자열을 결합할 때는 .toString()을 생략할 수 있다. 
```
System.out.println(p.toString() + "을/를 구입하셨습니다.");
System.out.println(p + "을/를 구입하셨습니다."); 
//위 두 줄은 동일.
```

예제 다시 복습하기.

### 여러 종류의 객체를 배열로 다루기

![[Pasted image 20231018225118.png]]
다형성의 두 번째 장점은 조상타입의 배열에 자손들의 객체를 담을 수 있다는 것이다.
원래는 하나의 배열에 같은 타입만 저장 가능. 하지만 다형성을 이용하면 여러 종류의 객체를 저장할 수 있다. 
위처럼 Tv, Computer, Audio 객체가 하나의 배열에 저장됨.


### 추상 클래스, 추상 메서드

![[Pasted image 20231019093853.png]]
추상 클래스는 미완성 설계도다. 미완성 메서드(추상 메서드)를 갖고 있으면 미완성 설계도다. 미완성 메서드는 구현부가 없는 경우.

추상 클래스는 설계도가 미완성인 경우다. 따라서 제품인 인스턴스를 생성 불가하다.
상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능.
그렇다면 추상 클래스 타입의 참조변수에 자손 객체를 대입할 수 있을까?
이런 질문은 그림으로 직관적으로 생각하면 생각이 쉽다.
Player.play()를 하면 자손 클래스의 메서드를 사용할 수가 있다고 한다.
p참조변수에 자손 객체를 대입하면 총 사용할 수 있는 객체가 추상 클래스 2개, 자손 클래스 2개 >> 따라서 조상 타입의 참조변수는 추상 클래스의 메서드를 사용하므로 에러가 날 줄 알았다. 하지만 자손의 멤버 play()를 사용할 수가 있다고 한다. 왜?
구현된 메서드를 사용한다고 한다. play(), stop()

![[Pasted image 20231019094923.png]]
자손마다 추상 메서드를 상속받아 다르게 구현할 수 있다.
AbstractPlayer 클래스는 Player 클래스를 상속받았지만 Player 클래스의 추상메서드 하나만 구현했기 때문에 abstarct 제어자를 붙여주어야 한다. 
그 이유는 AbstractPlayer 클래스의 메서드에는 생략되었지만 abstract void stop()이라는 메서드 또한 상속 받은 것이다. 따라서 abstract void stop() 이 메서드가 있기 때문에 abstract 제어자를 꼭 붙여주어야 한다.

### 추상 클래스의 작성

![[Pasted image 20231019102148.png]]
클래스들이 공통적으로 가지고 있는 부분을 추출해서 추상 클래스를 만든다.
그 후 상속받으니 코드가 더 간결해졌다. 

![[Pasted image 20231019102458.png]]
각 객체를 배열로 저장한 다음 각 각체의 move 메서드를 반복하여 모든 유닛을 (100, 200)이라는 좌표로 이동시킬 수 있다. 

### 추상 클래스의 작성 2
![[Pasted image 20231019104405.png]]
코드를 추상적으로 써놓으면 유연해서 변경에 유리하다.

### 인터페이스의 선언, 상속, 구현

인터페이스는 추상 메서드의 집합. 
물론 static 메서드, 상수, 디폴트 메서드도 요소가 되지만 부수적이다. 
핵심은 추상 메서드.

객체의 iv 변수에 접근하려면 메서드를 통해서 해야한다. (캡슐화)
예) t.hour 대신 t.getHour()

추상클래스와 인터페이스의 차이는?
추상클래스는 iv를 가진다.
인터페이스는 상수만 가지며 변수, iv, cv 다 가질 수 없다.

![[Pasted image 20231019105915.png]]
모든 인터페이스 멤버는 public이다. 
메서드는 모두 추상 메서드다. 

public abstract는 생략 가능하다. 왜?
모든 메서드는 public abstract이기 때문이다.
또한 public static final 역시 마찬가지. 생략가능하다.

![[Pasted image 20231019110108.png]]
인터페이스의 최고 조상은 Object가 아니다.
인터페이스의 조상은 인터페이스만 가능하다.
인터페이스는 다중 상속이 가능하다. 조상이 여럿.
원래는 여러 부모들의 같은 이름의 메서드를 호출하려면 어느 메서드를 호출해야 할 지 모르지만 추상 메서드는 이렇게 충돌할 일이 없다.
추상 메서드는 구현부가 없기 때문.

인터페이스 역시 미완성 설계도이기 때문에 상속을 해서 정의된 추상 메서드를 완성해야 한다. 이를 구현이라고 한다.

구현은 implements를 통해 가능하다.
인터페이스 역시 마찬가지로 일부만 구현하는 경우 클래스 앞에 abstract를 붙여야 한다. 


### 인터페이스와 다형성

![[Pasted image 20231019130719.png]]
클래스와 비슷하게 인터페이스 타입의 참조변수에 구현(자손)한 객체를 대입할 수 있다.
하지만 Fighter 클래스의 멤버 모두를 사용할 수는 없고인터페이스  Fightable의 메소드만 사용 가능하다. 대입받은 참조변수가 리모콘이라고 생각하면 리모콘에 버튼이 두 개이기 때문에 아무리 객체의 멤버가 많아도 버튼 두 개에 해당하는 객체만 사용가능 한 것이다.

매개변수가 타입이 인터페이스라는 의미는 인터페이스를 구현한 클래스의 인스턴스만 매개변수로 사용될 수 있다는 것을 의미한다.

![[Pasted image 20231019131129.png]]
메서드의 반환타입이 인터페이스라는 의미는 Fightable 인터페이스를 구현한 클래스의 인스턴스를 반환한 해야 한다는 의미다.
또한 메서드를 대입받는 참조변수의 타입 또한 인터페이스여야 한다.
인터페이스도 다형성이 가능하다. 

### 인터페이스의 장점 1





### 인터페이스의 장점 2





### 디폴트 메서드와 static 메서드





### 내부 클래스의 종류, 특징, 선언





### 내부 클래스의 제어자와 접근성






### 익명 클래스












