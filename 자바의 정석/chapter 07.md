### 상속
![[Pasted image 20231018101054.png]]

![[Pasted image 20231018101329.png]]
아래 자식 클래스는 멤버가 없는 게 아니다. 자신의 멤버는 0개지만 상속받은 멤버는 1개다.
자손의 변경은 조상에 영향을 미치지 않는다. 

![[Pasted image 20231018101605.png]]

### 클래스 간의 관계, 상속과 포함

![[Pasted image 20231018102949.png]]
클래스의 관계는 상속과 포함으로 나뉜다. 
우측 예시를 보면 circle은 point를 포함하고 있는 관계다.
point 클래스에 x, y 멤버변수를 선언하고, circle 클래스에 포함시켜 주었다.
포함 방법은 참조변수를 선언해주는 것.
포함할 클래스의 타입으로 참조변수를 선언하고 new 연산자로 생성자를 호출한다.

Cirlce c = new Circle(); 객체를 만들었다고 가정.
좌측 예시에서는 참조변수 c에 x, y, r 변수의 값이 담긴 객체의 주소가 대입된다.
우측 예시에서는 참조변수 c에 c(Point 타입)와 r 변수의 값이 담긴 객체의 주소가 대입되며,
c(Point 타입)는 자신이 참조하는 x, y의 값이 담긴 객체의 주소를 가진다. 
보통은 c.x, c.y, c.r 이렇게 멤버변수를 사용하지만,
Point 클래스의 멤버변수를 사용하려면 c.c.x, c.c.y 이런식으로.

스프링에서 서비스 또는 컨트롤러에 뜬금 없이 레파지토리나 도메인 클래스 타입을 가진 객체를 멤버 변수로 사용하는 것이 위와 같은 포함관계를 갖게 해준 것?

![[Pasted image 20231018103834.png]]
상속 관계를 갖게 해줘야 할 지 포함 관계를 갖게 해줘야 할 지 고민이라면 문장을 만들어 보면 된다. 
상속관계: ~은 ~이다.(is-a) / 포함관계: ~은 ~을 가지고 있다.(has-a)
예시는 두 번째가 "원은 점을 가지고 있다"라는 문장이 더 자연스럽기 때문에 포함관계로 설정해주면 된다. 
상속은 제한이 있기 때문에 꼭 필요할 때만 사용한다. 대부분 포함관계를 사용한다.

### 단일 상속, Object 클래스

![[Pasted image 20231018105635.png]]
자바는 단일상속만 허용한다. 하나의 부모로부터만 상속받음. 
class TvDVD extends Tv, DVD (x)
다중상속은 문제가 있다. 부모 클래스 모두 voidpower()라는 메서드가 있으면,
자식 클래스에서 voidpower() 메서드를 호출할 때 둘 중 어느 메서드를 호출해야 할 지 애매하다.

보통 비중이 높은 클래스 하나만 상속관계로 설정하고, 나머지는 포함관계로 설정한다.
인터페이스를 이용하면 위 같은 충돌문제를 해결하면서 다중상속을 할 수 있다.

![[Pasted image 20231018110337.png]]
Object 클래스는 모든 클래스의 조상이다. 
부모가 없는 클래스는 자동적으로 Object 클래스를 상속받는다. 
상속받는 클래스가 없는 클래스는 컴파일러가 자동으로 Object 클래스를 상속 받는다.
모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다.
toString(), equals(Object obj), hashCode()...
toString() 메서드는 클래스의 이름+@+주소값을 출력한다.

### 오버라이딩

![[Pasted image 20231018152025.png]]
오버라이딩은 상속받은 조상의 메서드를 자신에 맞게 변경하는 것이다. 
단 구현부만 변경할 수 있다.

![[Pasted image 20231018153254.png]]
![[Pasted image 20231018153237.png]]

![[Pasted image 20231018153706.png]]
오버로딩은 이름이 같을뿐 새로운 메서드를 정의하는 것이다.
오버라이딩도 새로운 메서드를 만드는 것은 맞다.
단 오버라이딩은 상속과 관계잇고 오버로딩은 상속과 관계가 없다.
5번은 중복정의 = 에러.

### 참조변수 super, 생성자 super()

참조변수 super는 this와 비슷하다. 인스턴스 메서드(생성자)내에서만 사용 가능하다. 
static 메서드에서 사용 불가하다.
조상의 멤버를 자신의 멤버와 구별할 때 사용한다. 
this는 lv와 iv 구분할 때.

![[Pasted image 20231018164648.png]]
부모 클래스의 멤버 변수 x, 자식 클래스의 멤버 변수도 x다. 값이 다르긴 하지만.
여기서 this는 인스턴스 자신을 가리키고 super는 부모 클래스를 가리킨다. 
첫 번째 x는 값이 20. 가장 가까운 값이 20이기 때문.
this.x는 값이 20. 인스턴스 자신을 가리키기 때문에 Child 클래스의 멤버변수. super.x는 값이 10. 부모 클래스의 값.

생성자와 초기화 블럭은 상속이 안 된다. 따라서 super()를 이용해 조상의 생성자를 호출해서 초기화한다. 

```
생성자란?
생성자는 멤버를 초기화 하는 메서드다.

생성자는 어떻게 초기화를 하는가?
new 연산자를 통해 생성자를 호출하면 객체(멤버)가 메모리에 올라가고,
기본 생성자일 경우 자동으로 초기화하여 0, null, boolean 등의 값으로 초기화,
생성자의 파라미터가 있는 경우 파라미터 값으로 초기화를 한다.

조상의 생성자를 호출한다는 것은?
조상의 객체(멤버)를 사용하기 위해 메모리에 올리고 멤버의 값을 초기화한다는 것.
```

![[Pasted image 20231018170852.png]]
super(x, y)는 Point(int x, int y)

![[Pasted image 20231018172354.png]]
(중요)생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
첫 줄에 생성자를 호출하지 않는 경우 컴파일러가 super();를 삽입한다.
우측의 super();는 Point 클래스의 조상인 Object의 기본 생성자를 호출하는 코드.

### 패키지, 클래스 패스



### import문, static import문


### 제어자, static, final, abstract



### 접근제어자



### 캡슐화





### 다형성



### 참조변수의 형변환




### 참조변수의 형변환2




### instanceof 연산자





### 매개변수다형성




### 여러 종류의 객체를 배열로 다루기





### 추상 클래스, 추상 메서드




### 추상 클래스의 작성




### 추상 클래스의 작성2






### 인터페이스의 선언, 상속, 구현





### 인터페이스와 다형성





### 인터페이스의 장점1





### 인터페이스의 장점2





### 디폴트 메서드와 static 메서드





### 내부 클래스의 종류, 특징, 선언





### 내부 클래스의 제어자와 접근성







### 익명 클래스












