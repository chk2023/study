### 23 연산자와 피연산자
![[Pasted image 20231010093028.png]]
![[Pasted image 20231010093127.png]]
### 24 연산자의 우선순위와 결합규칙
![[Pasted image 20231010093515.png]]
결합규칙은 연산 순서. 

![[Pasted image 20231010093913.png]]
단항= 피연산자가 1개

### 25 증감연산자, 부호연산자
![[Pasted image 20231010094421.png]]
독립적으로 사용된 경우?

![[Pasted image 20231010094652.png]]
헷갈리면 이렇게 생각하면 된다. 증가시키고 대입, 대입시키고 증가. 하지만 대입이 없고 독립적으로 사용된다면 전위형 후위형 차이 없음.

### 26 형변환 연산자, 자동 형변환
![[Pasted image 20231010100424.png]]
변수의 타입을 변환하려면 (타입)피연산자, 이렇게 해주면 된다.
소수를 정수로 변환하면 소숫점은 버려진다. 

자동 형변환은 앞에 (타입)을 붙여주지 않아도 범위가 작은 데이터 값을 범위가 큰 변수에 넣을 수 있다. 컴파일러가 자동으로 형변환을 해준다. 범위는 바이트 기준으로 생각하면 된다. 하지만 강제 형변환을 할 경우 값 손실이 있을 수 있다.

short와 char는 자동 형변환이 안 된다. short는 +/- 3만의 범위, char는 0~6만의 범위.

byte b = 100;
이때는 (타입)을 생략할 수 있다. byte의 범위는 -128~127이다. 따라서 int 타입인 100이 byte에 저장될 수 있기 때문에 컴파일러가 자동 형변환을 해준다. 하지만 100을 i라는 변수에 넣고 i를 byte에 넣어줄 때에는 수동으로 형변환을 해주어야 한다. 컴파일러가 i에 든 값을 확신할 수 없기 때문이다.

### 27 사칙 연산자, 산술변환



### 28 반올림 Math.round(), 나머지 연산



### 29

